## GO语言协程与调度

本文档主要关注go调度器的原理部分，讲述go调度器的工作原理；这里介绍的调度器无特殊说明均指go1.1版本后新的调度器；

### 简介

Dmitry Vyukov贡献的新的调度器是Go1.1版本的一个重大更新。新的调度器在并行go程序的调度性能上带来了惊人的增长。

### 设计目标

在学习新的调度器之前，我们必须知道我们为何需要它？为什么在操作系统提供线程调度的时候还提供个用户态的调度器？本节主要解决这两个问题。

熟悉POSIX API的人都知道，POSIX的方案在很大程度上是对Unix process进场模型的一个逻辑描述和扩展，两者有很多相似的地方。线程有它自己的信号掩码，可以指定cpu亲缘性，可以分配到组中来查询他们使用了那些资源。所有这些控件增加了一些额外的开销，这些功能对于goroutine是不需要的，并且当您的程序中有100,000个线程时，它们会快速累加带来很多不需要的系统开销。

另一个问题是OS不能基于Go模型做出明智的调度决定。举个例子，go的垃圾回收器运行垃圾回收的时候需要内存状态的一致性，依赖所有的线程停止工作。这需要线程运行到某些我们知道的点（内存是一致的）。当你有很多线程执行在一些随机位置时你需要等待更久。Go调度器可以在其知道内存一致的点处做出仅调度的决定。 这意味着当我们停止进行垃圾回收时，我们只需要等待CPU核心上正在运行的线程。

#### 并发模型

并发通常有3种模型，N:1,1:1,M:N：

在N:1模型中，多个用户线程运行在同一个操作系统线程上，好处是可以很快的上下文切换，缺点是不能发挥多核心的优势；

在1:1模型中，一个用户态的线程对应着一个操作系统线程，好处是可以很好的利用多核的优势，缺点是上下文切换很慢；

GO通过使用一种M:N的方式获取了两种调度方式的优点。它将任意数量的goroutine调度到任意数量的操作系统线程上。你可以同时使用多核的优势和快速的上下文切换，缺点是它大大的增加了调度器的复杂性；

### 调度原理

为了完成调度任务，GO语言引入了下面三种实体；

![实体]({{site.github.url}}/assets/golang-goroutine/1.jpg)

M表示操作系统线程，它是可以被操作系统控制执行的普通线程，像大多数的POSIX线程一样。在runtime的代码中，它叫做Machine。

G代表一个goroutine，它包含了堆栈信息、指令指针以及一些其他的调度信息，如它被阻塞的channel。

P表示调度器上下文，你可以将其看作是在单个线程上运行Go代码的调度程序的本地化版本。 这是让我们从N：1调度程序到M：N调度程序的重要部分。

![]({{site.github.url}}/assets/golang-goroutine/2.jpg)

这里有两个M，每个持有一个P，同时在执行一个goruntine G。一个M想要执行G就必须持有一个P。P的数量在启动的时候由环境变量GOMAXPROCS指定，或者在运行时通过函数GOMAXPROCS()指定。通常在执行成功的时候不会发送变化。事实上，上下文的数量是固定的意味着只有GOMAXPROCS在任何点上运行Go代码。 我们可以使用它来控制Go进程到其他计算机的调用，例如在4核的PC上使用4个线程上运行Go代码。

灰色的外部goruntine是当前虽然没有执行但是已经就绪等待执行的。他们被一个称为runqueue的队列管理。当启动一个goruntine的时候他会添加到队列的尾端。为了减少互斥代码的竞争，每个P都有它自己的本地队列。之前版本的go调度器只有一个全局的队列（通过全局的互斥锁维护）。线程经常等待互斥信号量的解锁。这在多核的机器上想榨取机器的性能几乎是不可能的。

队列中有就绪的goruntine会一直保持执行下去。但一些特定的外部场景可以改变这个状态。

#### 系统调用

你可能会疑惑为什么会有context的存在？直接把runqueue交给线程从而去掉context不行么？使用context的原因是线程阻塞的时候可以把他的runqueue给其他的线程执行。一般线程进行系统调用的时候会阻塞住，由于线程不能同时执行代码和在系统调用上阻塞，因此我们需要切换context以便context可以保持调度。

![]({{site.github.url}}/assets/golang-goroutine/3.jpg)

上图中一个线程放弃了它的context，以至于其他的线程可以执行它。调度器保证有足够的线程来处理context。图例中的M1就是为了这次系统调用产生的，它可以来自于系统创建或者来自于线程缓存。系统调用线程将保持系统调用的goroutine，因为它仍然在执行，虽然在操作系统中被阻塞。

当系统调用返回的时候，线程尝试获取一个上下文来返回当前执行的goruntine。通常的做法是从其他的线程偷取一个。如果偷不到的话，就把该goruntine放到全局的runqueue中，并把自己放到线程缓存中，之后执行sleep。

当context处理完自己本地的runqueue会尝试从全局的runqueue获取goruntine，同时context周期性的检查全局的runqueue，从而保证全局runqueue上的goruntine会被执行到。

这种处理系统调用的机制保证了即使GOMAXPROCS配置为1也能多线程执行。

#### 队列为空

另外一个调度发生变化的情况是当一个context处理光他的goruntine时。这发生在context的goruntine分配不均衡的情况。context耗尽其运行队列，同时仍然需要继续工作。 为了继续运行Go代码，context可以从全局runqueue获取goruntine，但是如果没有goroutine，它将必须从其他地方获取它们。

![]({{site.github.url}}/assets/golang-goroutine/4.jpg)

通常是从其他的context获取。当一个context跑光了，它将尝试从其他的context中偷取一般的goruntine。这保证了每个context都有事情做，同事也保证了所有的线程都以他们最大的工作能力在工作。

### 参考文献

[调度器说明](http://morsmachine.dk/go-scheduler)

[调度器设计文档](https://docs.google.com/document/d/1TTj4T2JO42uD5ID9e89oa0sLKhJYD0Y_kqxDv3I3XMw)